#include "USTC_CG.h"
#include "pxr/base/gf/math.h"

USTC_CG_NAMESPACE_OPEN_SCOPE

using namespace pxr;
inline GfVec3f CosineWeightedDirection(const GfVec2f& uniform_float, float& pdf)
{
    GfVec3f dir;
    float theta = 2.0f * M_PI * uniform_float[0];
    float eta = uniform_float[1];
    float sqrteta = sqrtf(eta);
    dir[0] = cosf(theta) * sqrteta;
    dir[1] = sinf(theta) * sqrteta;
    dir[2] = sqrtf(1.0f - eta);

    pdf = dir[2] / M_PI;
    return dir;
}


// This is generated by GPT... And it works quite well.
inline GfVec3f GGXWeightedDirection(const GfVec2f& uniform_float, float roughness, float& pdf)
{
    // Calculate the angle phi
    float phi = 2.0f * M_PI * uniform_float[0];

    // Calculate the roughness-dependent alpha value
    float alpha = roughness * roughness;

    // Calculate the tangent of the angle theta
    float tan_theta_sq = alpha * uniform_float[1] / (1.0f - uniform_float[1]);
    float cos_theta = 1.0f / std::sqrt(1.0f + tan_theta_sq);
    float sin_theta = std::sqrt(std::max(0.0f, 1.0f - cos_theta * cos_theta));

    // Convert spherical coordinates to Cartesian coordinates
    GfVec3f dir;
    dir[0] = std::cos(phi) * sin_theta;
    dir[1] = std::sin(phi) * sin_theta;
    dir[2] = cos_theta;

    // Calculate the PDF
    float d = 1.0f + (alpha * alpha - 1.0f) * cos_theta * cos_theta;
    pdf = alpha * alpha * M_PI / (d * d);

    return dir;
}

inline GfVec3f UniformSampleSphere(const GfVec2f& uniform_float, float& pdf)
{
    float theta = 2.0f * M_PI * uniform_float[0];
    float phi = acosf(2.0f * uniform_float[1] - 1.0f);
    float sin_phi = sinf(phi);

    pdf = 1.0 / 4 / M_PI;
    return GfVec3f(sin_phi * cosf(theta), sin_phi * sinf(theta), cosf(phi));
}

inline GfVec3f UniformSampleHemiSphere(const GfVec2f& uniform_float, float& pdf)
{
    auto ret = UniformSampleSphere(uniform_float, pdf);
    pdf *= 2;
    ret[2] = abs(ret[2]);
    return ret;
}

USTC_CG_NAMESPACE_CLOSE_SCOPE